<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="initial-scale=1, maximum-scale=1">
        
        <title>LARX 0.01</title>
        <link href="style.css" rel="stylesheet" />
                
        <!-- DIST -->
        <script src="/js/dist/q.js"></script>
        <script src="/js/dist/gl-matrix.js"></script>
        
        <!-- SCRIPTS -->
        <script src="/js/viewport.js"></script>
        
        <script src="/js/gl/engine.js"></script>
        <script src="/js/gl/matrix.js"></script>
        <script src="/js/gl/shaders.js"></script>
        <script src="/js/gl/camera.js"></script>
        <script src="/js/gl/model.js"></script>
        
        <script src="/js/gameLoop.js"></script>
        <script src="/js/terrain.js"></script>
        <script src="/js/water.js"></script>
        
        <script src="/js/shaders/defaultShader.js"></script>
        <script src="/js/shaders/waterShader.js"></script>
    </head>
    
    <body> 
        <div id="viewport">
            <div id="fullscreen">Fullscreen</div>
            <canvas class="renderTarget"></canvas>
        </div>
    </body>
    
    <!-- INITIALIZATION -->
    <script>
        
        var vp = new Viewport();
        var engine = new Engine(vp, init);
        var gameLoop = new GameLoop();
        var defaultShader, waterShader;
        var ctx;
        
        var terrain = new Terrain();
        var water = new Water();
        var mTrees, mWater, mTerrain;
        
        function init() {
            
            initShaders()
                .then(initTerrain)
                .then(initWater)
                .then(initTrees)
                .then(function() {
                    console.log('START')
                    gameLoop.start(40, doLogic, render);
                })
                .catch(function(err) {
                    console.error(err);
                })
        }
        
        function initShaders() {
            ctx = engine.get();
            
            defaultShader = new DefaultShader(ctx);
            waterShader = new WaterShader(ctx);
            
            return Q.all([
                defaultShader.load(ctx),
                waterShader.load(ctx)
            ]);            
        }
        
        function initTerrain() {
            var deferred = Q.defer();
            
            terrain.generatefromImage(ctx, '/maps/test', 9.0, 1.5, 1)              
                .then(function(t) {
                    mTerrain = t;
                    mTerrain.model.shininess = 4.0;
                    mTerrain.model.specularWeight = 0.35;  
                    
                    deferred.resolve(true);
                });
                
            return deferred.promise;
        }
        
        function initWater() {
            var quality = 2;
            var deferred = Q.defer();
            var tiles = Math.floor((mTerrain.size - 2) / quality);
            
            water.generate(ctx, waterShader, tiles, quality).then(function(w) {
                mWater = w;
                console.log(mWater);
                deferred.resolve(true);
            });
            
            return deferred.promise;
        }
        
        function initTrees() {
            var deferred = Q.defer();
                        
            ctx.model.load('tree').then(function(model) {
                ctx.model.create().then(function(target) {
                    var count = 0;
                    var bounds = (mTerrain.size / 2) - 2;
                    mTrees = target;
                    
                    while(count < 800) {
                        var tree = ctx.model.clone(model);
                        var x = Math.random() * (mTerrain.size - 2) - ((mTerrain.size - 2) / 2);
                        var z = Math.random() * (mTerrain.size - 2) - ((mTerrain.size - 2) / 2);
                        var y = parseFloat(terrain.getElevationAtPoint(mTerrain, x, z));
                        
                        if(y >= 1.8 && y < 4.5 && x > -bounds && x < bounds && z > -bounds && z < bounds) {
                            ctx.model.rotate(tree, Math.random() * Math.PI);
                            ctx.model.translate(tree, [x, y, z]);
                            ctx.model.push(mTrees, tree);
                            
                            count++;
                        }
                    }
                    
                    mTrees.shininess = 1.0;
                    mTrees.specularWeight = 1.0;
                    ctx.model.bindBuffers(mTrees);
                    console.log(mTrees);
                });
                
                deferred.resolve(true);
            });
            
            return deferred.promise;
        }
        
        function doLogic(time) {
            keyboard();
            mouse();
            
            water.update(ctx, mWater, time);
        }
        
        function render() {
            engine.render(function() {
                defaultShader.use();
                
                ctx.matrix.setIdentity();
                ctx.matrix.setUniforms(defaultShader);
                ctx.model.render(mTrees, defaultShader);
                
                ctx.matrix.setIdentity();
                ctx.matrix.setUniforms(defaultShader);
                ctx.model.render(mTerrain.model, defaultShader);
                
                waterShader.use();
                ctx.matrix.setIdentity();
                ctx.matrix.setUniforms(waterShader);
                ctx.model.render(mWater.model, waterShader);
            });
        }
        
        function keyboard() {
            if(vp.keyDown('W')) { ctx.camera.move( 0.0,  0.5); }
            if(vp.keyDown('S')) { ctx.camera.move( 0.0, -0.5); }
            if(vp.keyDown('A')) { ctx.camera.move(-0.5,  0.0); }
            if(vp.keyDown('D')) { ctx.camera.move( 0.5,  0.0); }
        }
        
        function mouse() {
            if(vp.mouse.buttons.right || vp.mouse.touchDown) {  
                var dX = vp.mouse.deltaX / 3.0,
                    dY = vp.mouse.deltaY / 3.0;
                    
                var cMatrix = ctx.camera.getMatrix();
                var dYRad = dY * Math.PI / 180;
                
                ctx.camera.rotate(dX, 0);
                
                if(dYRad > 0) {
                    if(cMatrix.rotV + dYRad < Math.PI - 0.2) { ctx.camera.rotate(0, dY); }
                } else {
                    if(cMatrix.rotV + dYRad > 0.2) { ctx.camera.rotate(0, dY); }
                }
            }
            
            if(vp.mouse.wheelDelta !== 0) {
                ctx.camera.zoom(-vp.mouse.wheelDelta * 2);
            }
            
            vp.resetDelta();
        }
        
        document.getElementById('fullscreen').onclick = function() {
            vp.toggleFullscreen();
        };
            
    </script>
</html>