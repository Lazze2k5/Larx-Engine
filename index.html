<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="initial-scale=1, maximum-scale=1">
        
        <title>LARX 0.01</title>
        <link href="style.css" rel="stylesheet" />
                
        <!-- DIST -->
        <script src="/js/dist/q.js"></script>
        <script src="/js/dist/gl-matrix.js"></script>
        
        <!-- SCRIPTS -->
        <script src="/js/viewport.js"></script>
        
        <script src="/js/gl/engine.js"></script>
        <script src="/js/gl/matrix.js"></script>
        <script src="/js/gl/shaders.js"></script>
        <script src="/js/gl/camera.js"></script>
        <script src="/js/gl/model.js"></script>
        
        <script src="/js/gameLoop.js"></script>
        <script src="/js/terrain.js"></script>
        <script src="/js/water.js"></script>
        
        <script src="/js/shaders/defaultShader.js"></script>
        <script src="/js/shaders/waterShader.js"></script>
    </head>
    
    <body> 
        <div id="viewport">
            <div id="fullscreen">Fullscreen</div>
            <canvas class="renderTarget"></canvas>
        </div>
    </body>
    
    <!-- INITIALIZATION -->
    <script>
        
        var vp = new Viewport();
        var engine = new Engine(vp, init);
        var gameLoop = new GameLoop();
        var defaultShader, waterShader;
        var ctx;
        
        var terrain = new Terrain();
        var water = new Water();
        var mTrees, mObjects, mWater, mTerrain;
        
        var waterColor = [0.359, 0.781, 0.800];
        
        function init() {
            
            initShaders()
                .then(initTerrain)
                .then(initWater)
                .then(initTrees)
                .then(initObjects)
                .then(function() {
                    console.log('START')
                    gameLoop.start(60, doLogic, render);
                })
                .catch(function(err) {
                    console.error(err);
                })
        }
        
        function initShaders() {
            var deferred = Q.defer();
            
            ctx = engine.get();
            
            defaultShader = new DefaultShader(ctx);
            waterShader = new WaterShader(ctx);
            
            Q.all([
                defaultShader.load(ctx),
                waterShader.load(ctx)
            ]).then(function() {
                defaultShader.setWaterColor(waterColor);
                waterShader.setWaterColor(waterColor);
                deferred.resolve();
            });
            
            return deferred.promise;         
        }
        
        function initTerrain() {
            var deferred = Q.defer();
            
            terrain.generatefromImage(ctx, '/maps/test', 9.0, 1.5, 1)              
                .then(function(t) {
                    mTerrain = t;
                    mTerrain.model.shininess = 4.0;
                    mTerrain.model.specularWeight = 0.35;  
                    
                    deferred.resolve(true);
                });
                
            return deferred.promise;
        }
        
        function initWater() {
            var quality = 48;
            var deferred = Q.defer();
            
            water.generate(ctx, waterShader, mTerrain, quality).then(function(w) {
                mWater = w;
                deferred.resolve(true);
            });
            
            return deferred.promise;
        }
        
        function initTrees() {
            var deferred = Q.defer();
                        
            ctx.model.load('tree').then(function(model) {
                var count = 0;
                var bounds = (mTerrain.size / 2) - 2;
                mTrees = ctx.model.create();
                
                while(count < 800) {
                    var tree = ctx.model.clone(model);
                    var x = Math.random() * (mTerrain.size - 2) - ((mTerrain.size - 2) / 2);
                    var z = Math.random() * (mTerrain.size - 2) - ((mTerrain.size - 2) / 2);
                    var y = terrain.getElevationAtPoint(mTerrain, x, z) - 0.02;
                    
                    var tx = (Math.random() - 0.5) * Math.PI / 12.0;
                    var ty = (Math.random() - 0.5) * Math.PI / 12.0;
                    
                    if(y >= 1.0 && y < 4.0 && x > -bounds && x < bounds && z > -bounds && z < bounds) {
                        ctx.model.rotate(tree, [tx, Math.random() * Math.PI, ty]);
                        ctx.model.translate(tree, [x, y, z]);
                        ctx.model.push(mTrees, tree);
                        
                        count++;
                    }
                }
                
                mTrees.shininess = 1.0;
                mTrees.specularWeight = 1.0;
                ctx.model.bindBuffers(mTrees);
                
                deferred.resolve(true);
            });
            
            return deferred.promise;
        }
        

        function initObjects() {
            var deferred = Q.defer();
            
            Q.all([
                ctx.model.load('rock-1'), 
                ctx.model.load('rock-2'), 
                ctx.model.load('crate')]).then(function(models) {
                var count = 0;
                var bounds = (mTerrain.size / 2) - 2;
                mObjects = ctx.model.create();
                
                
                while(count < 150) {
                    var rock = ctx.model.clone(models[Math.floor(Math.random() * models.length)]);
                    var x = Math.random() * (mTerrain.size - 2) - ((mTerrain.size - 2) / 2);
                    var z = Math.random() * (mTerrain.size - 2) - ((mTerrain.size - 2) / 2);
                    var y = terrain.getElevationAtPoint(mTerrain, x, z);
                    
                    if(y >= -2.0 && y < 3.5 && x > -bounds && x < bounds && z > -bounds && z < bounds) {
                        var angle = terrain.getAngle(mTerrain, x, z, 0.3, 0.3);
                        
                        ctx.model.rotate(rock, [0, Math.random() * Math.PI, 0]);
                        ctx.model.rotate(rock, angle);
                        ctx.model.translate(rock, [x, y, z]);
                        ctx.model.bindBuffers(rock); 
                        
                        ctx.model.push(mObjects, rock);
                        count ++;
                    }
                }
                
                mObjects.shininess = 1.0;
                mObjects.specularWeight = 0.7;
                ctx.model.bindBuffers(mObjects);
                deferred.resolve(true);
            });
            
            
            return deferred.promise;
        }
            
        function doLogic(time) {
            keyboard();
            mouse();
            
            water.update(ctx, mWater, time);
        }
        
        function render() {
            engine.render(function() {
                defaultShader.use();
                
                ctx.matrix.setIdentity();
                ctx.matrix.setUniforms(defaultShader);
                
                ctx.model.render(mTerrain.model, defaultShader);
                ctx.model.render(mTrees, defaultShader);
                ctx.model.render(mObjects, defaultShader);
                    
                water.render(ctx, waterShader);
            });
        }
        
        function keyboard() {
            if(vp.keyDown('W')) { ctx.camera.move( 0.0,  0.5); }
            if(vp.keyDown('S')) { ctx.camera.move( 0.0, -0.5); }
            if(vp.keyDown('A')) { ctx.camera.move(-0.5,  0.0); }
            if(vp.keyDown('D')) { ctx.camera.move( 0.5,  0.0); }
        }
        
        function mouse() {
            if(vp.mouse.buttons.right || vp.mouse.touchDown) {  
                var dX = vp.mouse.deltaX / 3.0,
                    dY = vp.mouse.deltaY / 3.0;
                    
                var cMatrix = ctx.camera.getMatrix();
                var dYRad = dY * Math.PI / 180;
                
                ctx.camera.rotate(dX, 0);
                
                if(dYRad > 0) {
                    if(cMatrix.rotV + dYRad < Math.PI - 0.2) { ctx.camera.rotate(0, dY); }
                } else {
                    if(cMatrix.rotV + dYRad > 0.2) { ctx.camera.rotate(0, dY); }
                }
            }
            
            if(vp.mouse.wheelDelta !== 0) {
                ctx.camera.zoom(-vp.mouse.wheelDelta * 2);
            }
            
            vp.resetDelta();
        }
        
        document.getElementById('fullscreen').onclick = function() {
            vp.toggleFullscreen();
        };
            
    </script>
</html>